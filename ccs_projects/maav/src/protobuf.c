/*******************************************************************
 * C file generated by Protoc for Embedded C.                      *
 * Version 1.0M4 (2013-03-31)                                      *
 *                                                                 *
 * Copyright (c) 2009-2013                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : protobuf.proto
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#include "Protobuf.h"

int _memcmp(const void *p1, const void *p2, unsigned int size) {
    unsigned int i;
    for(i = 0; i < size; ++ i) {
        if(*((char*)p1 + i) > *((char*)p2 + i))
            return 1;
        if(*((char*)p1 + i) < *((char*)p2 + i))
            return -1;
    }
    return 0;
}

void _memset(void *msg_ptr, char init_val, unsigned int size) {
    unsigned int i;
    for(i = 0; i < size; ++ i)
        *((char*)msg_ptr + i) = init_val;
}

int varint_packed_size(unsigned long value) {
    if ((value & (0xffffffff <<  7)) == 0) return 1;
    if ((value & (0xffffffff << 14)) == 0) return 2;
    if ((value & (0xffffffff << 21)) == 0) return 3;
    if ((value & (0xffffffff << 28)) == 0) return 4;
    return 5;
}

int write_raw_byte(char value, void *_buffer, int offset) {
    *((char *)_buffer + offset) = value;
    return ++offset;
}

/** Write a little-endian 32-bit integer. */
int write_raw_little_endian32(unsigned long value, void *_buffer, int offset) {
    offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);

    return offset;
}

/** Write a little-endian 64-bit integer. */
int write_raw_little_endian64(unsigned long long value, void *_buffer, int offset) {
    offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 32) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 40) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 48) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 56) & 0xFF), _buffer, offset);

    return offset;
}

int write_raw_varint32(unsigned long value, void *_buffer, int offset) {
    while (1) {
        if ((value & ~0x7F) == 0) {
            offset = write_raw_byte((char)value, _buffer, offset);
            return offset;
        } else {
            offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
            value = value >> 7;
        }
    }
    return offset;
}

int write_raw_varint64(unsigned long long value, void *_buffer, int offset) {
    while (1) {
        if ((value & ~0x7FL) == 0) {
            offset = write_raw_byte((char)value, _buffer, offset);
            return offset;
        } else {
            offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
            value = value >> 7;
        }
    }
    return offset;
}

int write_raw_bytes(char *bytes, int bytes_size, void *_buffer, int offset) {
    int i;
    for(i = 0; i < bytes_size; ++ i) {
        offset = write_raw_byte((char)*(bytes + i), _buffer, offset);
    }

    return offset;
}

unsigned long encode_zig_zag32(signed long n) {
    /* Note:  the right-shift must be arithmetic. */
    return (n << 1) ^ (n >> 31);
}

unsigned long long encode_zig_zag64(signed long long n) {
    /* Note:  the right-shift must be arithmetic. */
    return (n << 1) ^ (n >> 63);
}

signed long decode_zig_zag32(unsigned long n) {
    return (n >> 1) ^ -(n & 1);
}

signed long long decode_zig_zag64(unsigned long long n) {
    return (n >> 1) ^ -(n & 1);
}

int read_raw_byte(char *tag, void *_buffer, int offset) {
    *tag = *((char *) _buffer + offset);

    return ++offset;
}

/** Read a 32-bit little-endian integer from the stream. */
int read_raw_little_endian32(unsigned long *tag, void *_buffer, int offset) {
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b1 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b2 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b3 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b4 = (char) *tag;

    *tag = (((unsigned long)b1 & 0xff)      ) |
           (((unsigned long)b2 & 0xff) <<  8) |
           (((unsigned long)b3 & 0xff) << 16) |
           (((unsigned long)b4 & 0xff) << 24);

    return offset;
}

/** Read a 64-bit little-endian integer from the stream. */
int read_raw_little_endian64(unsigned long long *tag, void *_buffer, int offset) {
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b1 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b2 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b3 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b4 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b5 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b6 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b7 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b8 = (char) *tag;

    *tag = (((unsigned long long)b1 & 0xff)      ) |
           (((unsigned long long)b2 & 0xff) <<  8) |
           (((unsigned long long)b3 & 0xff) << 16) |
           (((unsigned long long)b4 & 0xff) << 24) |
           (((unsigned long long)b5 & 0xff) << 32) |
           (((unsigned long long)b6 & 0xff) << 40) |
           (((unsigned long long)b7 & 0xff) << 48) |
           (((unsigned long long)b8 & 0xff) << 56);

    return offset;
}

int read_raw_varint32(unsigned long *tag, void *_buffer, int offset) {
    signed char result;

    offset = read_raw_byte((char *)&result, _buffer, offset);
    if (result >= 0) {
        *tag = result;
        return offset;
    }
    *tag = result & 0x7f;
    offset = read_raw_byte((char *)&result, _buffer, offset);
    if (result >= 0) {
        *tag |= result << 7;
    } else {
        *tag |= (result & 0x7f) << 7;
        offset = read_raw_byte((char *)&result, _buffer, offset);
        if (result >= 0) {
            *tag |= result << 14;
        } else {
            *tag |= (result & 0x7f) << 14;
            offset = read_raw_byte((char *)&result, _buffer, offset);
            if (result >= 0) {
                *tag |= ((unsigned long)result) << 21;
            } else {
                *tag |= (((unsigned long)result) & 0x7f) << 21;
                offset = read_raw_byte((char *)&result, _buffer, offset);
                *tag |= ((unsigned long)result) << 28;
                if (result < 0) {
                    /* Discard upper 32 bits. */
                    int i;
                    for (i = 0; i < 5; ++ i) {
                        offset = read_raw_byte((char *)&result, _buffer, offset);
                        if (result >= 0) {
                            return offset;
                        }
                    }
                    /* Invalid state. */
                }
            }
        }
    }
    return offset;
}

int read_raw_varint64(unsigned long long *tag, void *_buffer, int offset) {
    short shift = 0;
    signed char b;
    *tag = 0;
    while (shift < 64) {
        offset = read_raw_byte((char *)&b, _buffer, offset);
        *tag |= (unsigned long long)(b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            return offset;
        }
        shift += 7;
    }
    /* return error code. */
    return -1;
}

int can_read_raw_varint32(void *_buffer, int offset, int length) {
    signed char c;

    /* Bound length to valid range [0..5]. */
    if (length < 0) length = 0; else
    if (length > 5) length = 5;

    while (length > 0) {
        offset = read_raw_byte((char *)&c, _buffer, offset);
        if (c >= 0) {
            return 1; /* Can read (1 == true). */
        }
        length--;
    }

    return 0; /* Cannot read (0 == false). */
}

int can_read_raw_varint64(void *_buffer, int offset, int length) {
    signed char c;

    /* Bound length to valid range [0..5]. */
    if (length < 0) length = 0; else
    if (length > 10) length = 10;

    while (length > 0) {
        offset = read_raw_byte((char *)&c, _buffer, offset);
        if (c >= 0) {
            return 1; /* Can read (1 == true). */
        }
        length--;
    }

    return 0; /* Cannot read (0 == false). */
}

int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length) {
    unsigned long size;
    int payload_offset;

    if (length <= 0) return 0; /* Cannot read from empty or invalid message. */

    if (!can_read_raw_varint32(_buffer, offset, length)) {
        return 0; /* Could not even read the preceding size as varint32. */
    }

    payload_offset = read_raw_varint32(&size, _buffer, offset);
    length = length - (payload_offset - offset);

    return (length >= size) ? 1 : 0;
}

unsigned long Message_get_delimited_size(void *_buffer, int offset) {
    unsigned long size = 0;
    int old_offset = offset;

    offset = read_raw_varint32(&size, _buffer, offset);

    return size + offset - old_offset;
}

/*******************************************************************
 * Message: Protobuf.proto, line 97
 *******************************************************************/

void feedback_clear(struct feedback *_feedback) {
	_memset(_feedback, 0, sizeof(struct feedback));
}

void feedback_init_optional_attributes(struct feedback *_feedback) {
	_feedback->_xest = 0.0f;

	_feedback->_yest = 0.0f;

	_feedback->_zest = 0.0f;

	_feedback->_rest = 0.0f;

	_feedback->_pest = 0.0f;

	_feedback->_hest = 0.0f;

	_feedback->_xdot = 0.0f;

	_feedback->_ydot = 0.0f;

	_feedback->_zdot = 0.0f;

	_feedback->_Ax = 0.0f;

	_feedback->_Ay = 0.0f;

	_feedback->_Az = 0.0f;

	_feedback->_rdot = 0.0f;

	_feedback->_pdot = 0.0f;

	_feedback->_hdot = 0.0f;

}

int feedback_is_default_message(struct feedback *_feedback) {
    return _feedback->_cmd == 0

     && _feedback->_timestamp == 0.0f

     && _feedback->_xest == 0.0f

     && _feedback->_yest == 0.0f

     && _feedback->_zest == 0.0f

     && _feedback->_rest == 0.0f

     && _feedback->_pest == 0.0f

     && _feedback->_hest == 0.0f

     && _feedback->_status == 0

     && _feedback->_xdot == 0.0f

     && _feedback->_ydot == 0.0f

     && _feedback->_zdot == 0.0f

     && _feedback->_Ax == 0.0f

     && _feedback->_Ay == 0.0f

     && _feedback->_Az == 0.0f

     && _feedback->_rdot == 0.0f

     && _feedback->_pdot == 0.0f

     && _feedback->_hdot == 0.0f
    ;
}

int feedback_write(struct feedback *_feedback, void *_buffer, int offset) {
	/* Write content of each message element.*/
	offset = write_raw_varint32((1<<3)+0, _buffer, offset);
	offset = write_raw_varint32(_feedback->_cmd, _buffer, offset);

	offset = write_raw_varint32((2<<3)+5, _buffer, offset);
	unsigned long *timestamp_ptr = (unsigned long *)&_feedback->_timestamp;
	offset = write_raw_little_endian32(*timestamp_ptr, _buffer, offset);

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_xest != 0) {
		offset = write_raw_varint32((7<<3)+5, _buffer, offset);
	    unsigned long *xest_ptr = (unsigned long *)&_feedback->_xest;
	    offset = write_raw_little_endian32(*xest_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_yest != 0) {
		offset = write_raw_varint32((8<<3)+5, _buffer, offset);
	    unsigned long *yest_ptr = (unsigned long *)&_feedback->_yest;
	    offset = write_raw_little_endian32(*yest_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_zest != 0) {
		offset = write_raw_varint32((9<<3)+5, _buffer, offset);
	    unsigned long *zest_ptr = (unsigned long *)&_feedback->_zest;
	    offset = write_raw_little_endian32(*zest_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_rest != 0) {
		offset = write_raw_varint32((10<<3)+5, _buffer, offset);
	    unsigned long *rest_ptr = (unsigned long *)&_feedback->_rest;
	    offset = write_raw_little_endian32(*rest_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_pest != 0) {
		offset = write_raw_varint32((11<<3)+5, _buffer, offset);
	    unsigned long *pest_ptr = (unsigned long *)&_feedback->_pest;
	    offset = write_raw_little_endian32(*pest_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_hest != 0) {
		offset = write_raw_varint32((12<<3)+5, _buffer, offset);
	    unsigned long *hest_ptr = (unsigned long *)&_feedback->_hest;
	    offset = write_raw_little_endian32(*hest_ptr, _buffer, offset);
	}

	offset = write_raw_varint32((13<<3)+0, _buffer, offset);
	offset = write_raw_varint32(_feedback->_status, _buffer, offset);

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_xdot != 0) {
		offset = write_raw_varint32((14<<3)+5, _buffer, offset);
	    unsigned long *xdot_ptr = (unsigned long *)&_feedback->_xdot;
	    offset = write_raw_little_endian32(*xdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_ydot != 0) {
		offset = write_raw_varint32((15<<3)+5, _buffer, offset);
	    unsigned long *ydot_ptr = (unsigned long *)&_feedback->_ydot;
	    offset = write_raw_little_endian32(*ydot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_zdot != 0) {
		offset = write_raw_varint32((16<<3)+5, _buffer, offset);
	    unsigned long *zdot_ptr = (unsigned long *)&_feedback->_zdot;
	    offset = write_raw_little_endian32(*zdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_Ax != 0) {
		offset = write_raw_varint32((17<<3)+5, _buffer, offset);
	    unsigned long *Ax_ptr = (unsigned long *)&_feedback->_Ax;
	    offset = write_raw_little_endian32(*Ax_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_Ay != 0) {
		offset = write_raw_varint32((18<<3)+5, _buffer, offset);
	    unsigned long *Ay_ptr = (unsigned long *)&_feedback->_Ay;
	    offset = write_raw_little_endian32(*Ay_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_Az != 0) {
		offset = write_raw_varint32((19<<3)+5, _buffer, offset);
	    unsigned long *Az_ptr = (unsigned long *)&_feedback->_Az;
	    offset = write_raw_little_endian32(*Az_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_rdot != 0) {
		offset = write_raw_varint32((20<<3)+5, _buffer, offset);
	    unsigned long *rdot_ptr = (unsigned long *)&_feedback->_rdot;
	    offset = write_raw_little_endian32(*rdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_pdot != 0) {
		offset = write_raw_varint32((21<<3)+5, _buffer, offset);
	    unsigned long *pdot_ptr = (unsigned long *)&_feedback->_pdot;
	    offset = write_raw_little_endian32(*pdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_feedback->_hdot != 0) {
		offset = write_raw_varint32((22<<3)+5, _buffer, offset);
	    unsigned long *hdot_ptr = (unsigned long *)&_feedback->_hdot;
	    offset = write_raw_little_endian32(*hdot_ptr, _buffer, offset);
	}

	return offset;
}

int feedback_write_with_tag(struct feedback *_feedback, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = feedback_write_delimited_to(_feedback, _buffer, offset);

	return offset;
}

int feedback_write_delimited_to(struct feedback *_feedback, void *_buffer, int offset) {
	int i, shift, new_offset, size;

	new_offset = feedback_write(_feedback, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);

	write_raw_varint32((unsigned long) size, _buffer, offset);

	return new_offset + shift;
}

int feedback_read(void *_buffer, struct feedback *_feedback, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;

	/* Reset all attributes to 0 in advance. */
	feedback_clear(_feedback);
	/* Assign the optional attributes. */
	feedback_init_optional_attributes(_feedback);

	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _feedback._cmd */
	        case 1 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_feedback->_cmd = tag;
	        	break;
	        /* tag of: _feedback._timestamp */
	        case 2 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *timestamp = (float *)(&tag);
	        	_feedback->_timestamp = *timestamp;
	        	break;
	        /* tag of: _feedback._xest */
	        case 7 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *xest = (float *)(&tag);
	        	_feedback->_xest = *xest;
	        	break;
	        /* tag of: _feedback._yest */
	        case 8 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *yest = (float *)(&tag);
	        	_feedback->_yest = *yest;
	        	break;
	        /* tag of: _feedback._zest */
	        case 9 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *zest = (float *)(&tag);
	        	_feedback->_zest = *zest;
	        	break;
	        /* tag of: _feedback._rest */
	        case 10 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *rest = (float *)(&tag);
	        	_feedback->_rest = *rest;
	        	break;
	        /* tag of: _feedback._pest */
	        case 11 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *pest = (float *)(&tag);
	        	_feedback->_pest = *pest;
	        	break;
	        /* tag of: _feedback._hest */
	        case 12 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *hest = (float *)(&tag);
	        	_feedback->_hest = *hest;
	        	break;
	        /* tag of: _feedback._status */
	        case 13 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_feedback->_status = tag;
	        	break;
	        /* tag of: _feedback._xdot */
	        case 14 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *xdot = (float *)(&tag);
	        	_feedback->_xdot = *xdot;
	        	break;
	        /* tag of: _feedback._ydot */
	        case 15 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *ydot = (float *)(&tag);
	        	_feedback->_ydot = *ydot;
	        	break;
	        /* tag of: _feedback._zdot */
	        case 16 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *zdot = (float *)(&tag);
	        	_feedback->_zdot = *zdot;
	        	break;
	        /* tag of: _feedback._Ax */
	        case 17 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *Ax = (float *)(&tag);
	        	_feedback->_Ax = *Ax;
	        	break;
	        /* tag of: _feedback._Ay */
	        case 18 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *Ay = (float *)(&tag);
	        	_feedback->_Ay = *Ay;
	        	break;
	        /* tag of: _feedback._Az */
	        case 19 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *Az = (float *)(&tag);
	        	_feedback->_Az = *Az;
	        	break;
	        /* tag of: _feedback._rdot */
	        case 20 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *rdot = (float *)(&tag);
	        	_feedback->_rdot = *rdot;
	        	break;
	        /* tag of: _feedback._pdot */
	        case 21 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *pdot = (float *)(&tag);
	        	_feedback->_pdot = *pdot;
	        	break;
	        /* tag of: _feedback._hdot */
	        case 22 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *hdot = (float *)(&tag);
	        	_feedback->_hdot = *hdot;
	        	break;
	    }
	}

	return offset;
}

int feedback_read_delimited_from(void *_buffer, struct feedback *_feedback, int offset) {
	unsigned long size;

	offset = read_raw_varint32(&size, _buffer, offset);
	feedback_read(_buffer, _feedback, offset, size + offset);

	return offset + size;
}
/*******************************************************************
 * Message: Protobuf.proto, line 121
 *******************************************************************/

void all_clear(struct all *_all) {
	_memset(_all, 0, sizeof(struct all));
}

void all_init_optional_attributes(struct all *_all) {
	_all->_x = 0.0f;

	_all->_y = 0.0f;

	_all->_z = 0.0f;

	_all->_h = 0.0f;

	_all->_xactual = 0.0f;

	_all->_yactual = 0.0f;

	_all->_zactual = 0.0f;

	_all->_KPX = 0.0f;

	_all->_KIX = 0.0f;

	_all->_KDX = 0.0f;

	_all->_KPY = 0.0f;

	_all->_KIY = 0.0f;

	_all->_KDY = 0.0f;

	_all->_KPZ = 0.0f;

	_all->_KIZ = 0.0f;

	_all->_KDZ = 0.0f;

	_all->_KPXdot = 0.0f;

	_all->_KIXdot = 0.0f;

	_all->_KDXdot = 0.0f;

	_all->_KPYdot = 0.0f;

	_all->_KIYdot = 0.0f;

	_all->_KDYdot = 0.0f;

	_all->_KPZdot = 0.0f;

	_all->_KIZdot = 0.0f;

	_all->_KDZdot = 0.0f;

	_all->_KPH = 0.0f;

	_all->_KIH = 0.0f;

	_all->_KDH = 0.0f;

	_all->_xdot = 0.0f;

	_all->_ydot = 0.0f;

	_all->_zdot = 0.0f;

}

int all_is_default_message(struct all *_all) {
    return _all->_cmd == 0

     && _all->_timestamp == 0

     && _all->_x == 0.0f

     && _all->_y == 0.0f

     && _all->_z == 0.0f

     && _all->_h == 0.0f

     && _all->_xactual == 0.0f

     && _all->_yactual == 0.0f

     && _all->_zactual == 0.0f

     && _all->_KPX == 0.0f

     && _all->_KIX == 0.0f

     && _all->_KDX == 0.0f

     && _all->_KPY == 0.0f

     && _all->_KIY == 0.0f

     && _all->_KDY == 0.0f

     && _all->_KPZ == 0.0f

     && _all->_KIZ == 0.0f

     && _all->_KDZ == 0.0f

     && _all->_KPXdot == 0.0f

     && _all->_KIXdot == 0.0f

     && _all->_KDXdot == 0.0f

     && _all->_KPYdot == 0.0f

     && _all->_KIYdot == 0.0f

     && _all->_KDYdot == 0.0f

     && _all->_KPZdot == 0.0f

     && _all->_KIZdot == 0.0f

     && _all->_KDZdot == 0.0f

     && _all->_KPH == 0.0f

     && _all->_KIH == 0.0f

     && _all->_KDH == 0.0f

     && _all->_xdot == 0.0f

     && _all->_ydot == 0.0f

     && _all->_zdot == 0.0f
    ;
}

int all_write(struct all *_all, void *_buffer, int offset) {
	/* Write content of each message element.*/
	offset = write_raw_varint32((1<<3)+0, _buffer, offset);
	offset = write_raw_varint32(_all->_cmd, _buffer, offset);

	offset = write_raw_varint32((2<<3)+0, _buffer, offset);
	offset = write_raw_varint32(_all->_timestamp, _buffer, offset);

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_x != 0) {
		offset = write_raw_varint32((3<<3)+5, _buffer, offset);
	    unsigned long *x_ptr = (unsigned long *)&_all->_x;
	    offset = write_raw_little_endian32(*x_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_y != 0) {
		offset = write_raw_varint32((4<<3)+5, _buffer, offset);
	    unsigned long *y_ptr = (unsigned long *)&_all->_y;
	    offset = write_raw_little_endian32(*y_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_z != 0) {
		offset = write_raw_varint32((5<<3)+5, _buffer, offset);
	    unsigned long *z_ptr = (unsigned long *)&_all->_z;
	    offset = write_raw_little_endian32(*z_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_h != 0) {
		offset = write_raw_varint32((6<<3)+5, _buffer, offset);
	    unsigned long *h_ptr = (unsigned long *)&_all->_h;
	    offset = write_raw_little_endian32(*h_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_xactual != 0) {
		offset = write_raw_varint32((7<<3)+5, _buffer, offset);
	    unsigned long *xactual_ptr = (unsigned long *)&_all->_xactual;
	    offset = write_raw_little_endian32(*xactual_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_yactual != 0) {
		offset = write_raw_varint32((8<<3)+5, _buffer, offset);
	    unsigned long *yactual_ptr = (unsigned long *)&_all->_yactual;
	    offset = write_raw_little_endian32(*yactual_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_zactual != 0) {
		offset = write_raw_varint32((9<<3)+5, _buffer, offset);
	    unsigned long *zactual_ptr = (unsigned long *)&_all->_zactual;
	    offset = write_raw_little_endian32(*zactual_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KPX != 0) {
		offset = write_raw_varint32((30<<3)+5, _buffer, offset);
	    unsigned long *KPX_ptr = (unsigned long *)&_all->_KPX;
	    offset = write_raw_little_endian32(*KPX_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KIX != 0) {
		offset = write_raw_varint32((31<<3)+5, _buffer, offset);
	    unsigned long *KIX_ptr = (unsigned long *)&_all->_KIX;
	    offset = write_raw_little_endian32(*KIX_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KDX != 0) {
		offset = write_raw_varint32((32<<3)+5, _buffer, offset);
	    unsigned long *KDX_ptr = (unsigned long *)&_all->_KDX;
	    offset = write_raw_little_endian32(*KDX_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KPY != 0) {
		offset = write_raw_varint32((33<<3)+5, _buffer, offset);
	    unsigned long *KPY_ptr = (unsigned long *)&_all->_KPY;
	    offset = write_raw_little_endian32(*KPY_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KIY != 0) {
		offset = write_raw_varint32((34<<3)+5, _buffer, offset);
	    unsigned long *KIY_ptr = (unsigned long *)&_all->_KIY;
	    offset = write_raw_little_endian32(*KIY_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KDY != 0) {
		offset = write_raw_varint32((35<<3)+5, _buffer, offset);
	    unsigned long *KDY_ptr = (unsigned long *)&_all->_KDY;
	    offset = write_raw_little_endian32(*KDY_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KPZ != 0) {
		offset = write_raw_varint32((36<<3)+5, _buffer, offset);
	    unsigned long *KPZ_ptr = (unsigned long *)&_all->_KPZ;
	    offset = write_raw_little_endian32(*KPZ_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KIZ != 0) {
		offset = write_raw_varint32((37<<3)+5, _buffer, offset);
	    unsigned long *KIZ_ptr = (unsigned long *)&_all->_KIZ;
	    offset = write_raw_little_endian32(*KIZ_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KDZ != 0) {
		offset = write_raw_varint32((38<<3)+5, _buffer, offset);
	    unsigned long *KDZ_ptr = (unsigned long *)&_all->_KDZ;
	    offset = write_raw_little_endian32(*KDZ_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KPXdot != 0) {
		offset = write_raw_varint32((39<<3)+5, _buffer, offset);
	    unsigned long *KPXdot_ptr = (unsigned long *)&_all->_KPXdot;
	    offset = write_raw_little_endian32(*KPXdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KIXdot != 0) {
		offset = write_raw_varint32((40<<3)+5, _buffer, offset);
	    unsigned long *KIXdot_ptr = (unsigned long *)&_all->_KIXdot;
	    offset = write_raw_little_endian32(*KIXdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KDXdot != 0) {
		offset = write_raw_varint32((41<<3)+5, _buffer, offset);
	    unsigned long *KDXdot_ptr = (unsigned long *)&_all->_KDXdot;
	    offset = write_raw_little_endian32(*KDXdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KPYdot != 0) {
		offset = write_raw_varint32((42<<3)+5, _buffer, offset);
	    unsigned long *KPYdot_ptr = (unsigned long *)&_all->_KPYdot;
	    offset = write_raw_little_endian32(*KPYdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KIYdot != 0) {
		offset = write_raw_varint32((43<<3)+5, _buffer, offset);
	    unsigned long *KIYdot_ptr = (unsigned long *)&_all->_KIYdot;
	    offset = write_raw_little_endian32(*KIYdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KDYdot != 0) {
		offset = write_raw_varint32((44<<3)+5, _buffer, offset);
	    unsigned long *KDYdot_ptr = (unsigned long *)&_all->_KDYdot;
	    offset = write_raw_little_endian32(*KDYdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KPZdot != 0) {
		offset = write_raw_varint32((45<<3)+5, _buffer, offset);
	    unsigned long *KPZdot_ptr = (unsigned long *)&_all->_KPZdot;
	    offset = write_raw_little_endian32(*KPZdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KIZdot != 0) {
		offset = write_raw_varint32((46<<3)+5, _buffer, offset);
	    unsigned long *KIZdot_ptr = (unsigned long *)&_all->_KIZdot;
	    offset = write_raw_little_endian32(*KIZdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KDZdot != 0) {
		offset = write_raw_varint32((47<<3)+5, _buffer, offset);
	    unsigned long *KDZdot_ptr = (unsigned long *)&_all->_KDZdot;
	    offset = write_raw_little_endian32(*KDZdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KPH != 0) {
		offset = write_raw_varint32((48<<3)+5, _buffer, offset);
	    unsigned long *KPH_ptr = (unsigned long *)&_all->_KPH;
	    offset = write_raw_little_endian32(*KPH_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KIH != 0) {
		offset = write_raw_varint32((49<<3)+5, _buffer, offset);
	    unsigned long *KIH_ptr = (unsigned long *)&_all->_KIH;
	    offset = write_raw_little_endian32(*KIH_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_KDH != 0) {
		offset = write_raw_varint32((50<<3)+5, _buffer, offset);
	    unsigned long *KDH_ptr = (unsigned long *)&_all->_KDH;
	    offset = write_raw_little_endian32(*KDH_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_xdot != 0) {
		offset = write_raw_varint32((51<<3)+5, _buffer, offset);
	    unsigned long *xdot_ptr = (unsigned long *)&_all->_xdot;
	    offset = write_raw_little_endian32(*xdot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_ydot != 0) {
		offset = write_raw_varint32((52<<3)+5, _buffer, offset);
	    unsigned long *ydot_ptr = (unsigned long *)&_all->_ydot;
	    offset = write_raw_little_endian32(*ydot_ptr, _buffer, offset);
	}

	/* Write the optional attribute only if it is different than the default value. */
	if(_all->_zdot != 0) {
		offset = write_raw_varint32((53<<3)+5, _buffer, offset);
	    unsigned long *zdot_ptr = (unsigned long *)&_all->_zdot;
	    offset = write_raw_little_endian32(*zdot_ptr, _buffer, offset);
	}

	return offset;
}

int all_write_with_tag(struct all *_all, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = all_write_delimited_to(_all, _buffer, offset);

	return offset;
}

int all_write_delimited_to(struct all *_all, void *_buffer, int offset) {
	int i, shift, new_offset, size;

	new_offset = all_write(_all, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);

	write_raw_varint32((unsigned long) size, _buffer, offset);

	return new_offset + shift;
}

int all_read(void *_buffer, struct all *_all, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;

	//TODO: If protobuf.c/h regenerated, comment these things out to make sure new messages don't interfere with old data
	/* Reset all attributes to 0 in advance. */
	//all_clear(_all);
	/* Assign the optional attributes. */
	//all_init_optional_attributes(_all);

	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _all._cmd */
	        case 1 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_all->_cmd |= tag; //TODO: If new protobuf.c/h are regenerated, remember to replace = with |= to preserve "flag" functionality of cmd
	        	break;
	        /* tag of: _all._timestamp */
	        case 2 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_all->_timestamp = tag;
	        	break;
	        /* tag of: _all._x */
	        case 3 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *x = (float *)(&tag);
	        	_all->_x = *x;
	        	break;
	        /* tag of: _all._y */
	        case 4 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *y = (float *)(&tag);
	        	_all->_y = *y;
	        	break;
	        /* tag of: _all._z */
	        case 5 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *z = (float *)(&tag);
	        	_all->_z = *z;
	        	break;
	        /* tag of: _all._h */
	        case 6 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *h = (float *)(&tag);
	        	_all->_h = *h;
	        	break;
	        /* tag of: _all._xactual */
	        case 7 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *xactual = (float *)(&tag);
	        	_all->_xactual = *xactual;
	        	break;
	        /* tag of: _all._yactual */
	        case 8 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *yactual = (float *)(&tag);
	        	_all->_yactual = *yactual;
	        	break;
	        /* tag of: _all._zactual */
	        case 9 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *zactual = (float *)(&tag);
	        	_all->_zactual = *zactual;
	        	break;
	        /* tag of: _all._KPX */
	        case 30 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KPX = (float *)(&tag);
	        	_all->_KPX = *KPX;
	        	break;
	        /* tag of: _all._KIX */
	        case 31 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KIX = (float *)(&tag);
	        	_all->_KIX = *KIX;
	        	break;
	        /* tag of: _all._KDX */
	        case 32 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KDX = (float *)(&tag);
	        	_all->_KDX = *KDX;
	        	break;
	        /* tag of: _all._KPY */
	        case 33 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KPY = (float *)(&tag);
	        	_all->_KPY = *KPY;
	        	break;
	        /* tag of: _all._KIY */
	        case 34 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KIY = (float *)(&tag);
	        	_all->_KIY = *KIY;
	        	break;
	        /* tag of: _all._KDY */
	        case 35 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KDY = (float *)(&tag);
	        	_all->_KDY = *KDY;
	        	break;
	        /* tag of: _all._KPZ */
	        case 36 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KPZ = (float *)(&tag);
	        	_all->_KPZ = *KPZ;
	        	break;
	        /* tag of: _all._KIZ */
	        case 37 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KIZ = (float *)(&tag);
	        	_all->_KIZ = *KIZ;
	        	break;
	        /* tag of: _all._KDZ */
	        case 38 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KDZ = (float *)(&tag);
	        	_all->_KDZ = *KDZ;
	        	break;
	        /* tag of: _all._KPXdot */
	        case 39 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KPXdot = (float *)(&tag);
	        	_all->_KPXdot = *KPXdot;
	        	break;
	        /* tag of: _all._KIXdot */
	        case 40 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KIXdot = (float *)(&tag);
	        	_all->_KIXdot = *KIXdot;
	        	break;
	        /* tag of: _all._KDXdot */
	        case 41 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KDXdot = (float *)(&tag);
	        	_all->_KDXdot = *KDXdot;
	        	break;
	        /* tag of: _all._KPYdot */
	        case 42 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KPYdot = (float *)(&tag);
	        	_all->_KPYdot = *KPYdot;
	        	break;
	        /* tag of: _all._KIYdot */
	        case 43 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KIYdot = (float *)(&tag);
	        	_all->_KIYdot = *KIYdot;
	        	break;
	        /* tag of: _all._KDYdot */
	        case 44 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KDYdot = (float *)(&tag);
	        	_all->_KDYdot = *KDYdot;
	        	break;
	        /* tag of: _all._KPZdot */
	        case 45 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KPZdot = (float *)(&tag);
	        	_all->_KPZdot = *KPZdot;
	        	break;
	        /* tag of: _all._KIZdot */
	        case 46 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KIZdot = (float *)(&tag);
	        	_all->_KIZdot = *KIZdot;
	        	break;
	        /* tag of: _all._KDZdot */
	        case 47 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KDZdot = (float *)(&tag);
	        	_all->_KDZdot = *KDZdot;
	        	break;
	        /* tag of: _all._KPH */
	        case 48 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KPH = (float *)(&tag);
	        	_all->_KPH = *KPH;
	        	break;
	        /* tag of: _all._KIH */
	        case 49 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KIH = (float *)(&tag);
	        	_all->_KIH = *KIH;
	        	break;
	        /* tag of: _all._KDH */
	        case 50 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *KDH = (float *)(&tag);
	        	_all->_KDH = *KDH;
	        	break;
	        /* tag of: _all._xdot */
	        case 51 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *xdot = (float *)(&tag);
	        	_all->_xdot = *xdot;
	        	break;
	        /* tag of: _all._ydot */
	        case 52 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *ydot = (float *)(&tag);
	        	_all->_ydot = *ydot;
	        	break;
	        /* tag of: _all._zdot */
	        case 53 :
	        	offset = read_raw_little_endian32(&tag, _buffer, offset);
	        	float *zdot = (float *)(&tag);
	        	_all->_zdot = *zdot;
	        	break;
	    }
	}

	return offset;
}

int all_read_delimited_from(void *_buffer, struct all *_all, int offset) {
	unsigned long size;

	offset = read_raw_varint32(&size, _buffer, offset);
	all_read(_buffer, _all, offset, size + offset);

	return offset + size;
}
